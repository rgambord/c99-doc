<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6.5.2.5 Compound literals &mdash; C99 Language Standard  documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/brand.css" type="text/css" />
    <link rel="shortcut icon" href="../../../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link rel="next" title="6.5.3 Unary operators" href="../../3/index.html" />
    <link rel="prev" title="6.5.2.4 Postfix increment and decrement operators" href="../4/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            C99 Language Standard
              <img src="../../../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../foreword.html">Foreword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../1/index.html">1. Scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../2/index.html">2. Normative references</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../3/index.html">3. Terms, definitions, and symbols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../4/index.html">4. Conformance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../5/index.html">5. Environment</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">6. Language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../1/index.html">6.1 Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../2/index.html">6.2 Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../3/index.html">6.3 Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../4/index.html">6.4 Lexical elements</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html">6.5 Expressions</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../1/index.html">6.5.1 Primary expressions</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">6.5.2 Postfix operators</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../1/index.html">6.5.2.1 Array subscripting</a></li>
<li class="toctree-l4"><a class="reference internal" href="../2/index.html">6.5.2.2 Function calls</a></li>
<li class="toctree-l4"><a class="reference internal" href="../3/index.html">6.5.2.3 Structure and union members</a></li>
<li class="toctree-l4"><a class="reference internal" href="../4/index.html">6.5.2.4 Postfix increment and decrement operators</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">6.5.2.5 Compound literals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../3/index.html">6.5.3 Unary operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../4/index.html">6.5.4 Cast operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../5/index.html">6.5.5 Multiplicative operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../6/index.html">6.5.6 Additive operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../7/index.html">6.5.7 Bitwise shift operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../8/index.html">6.5.8 Relational operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../9/index.html">6.5.9 Equality operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../10/index.html">6.5.10 Bitwise AND operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../11/index.html">6.5.11 Bitwise exclusive OR operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../12/index.html">6.5.12 Bitwise inclusive OR operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../13/index.html">6.5.13 Logical AND operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../14/index.html">6.5.14 Logical OR operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../15/index.html">6.5.15 Conditional operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../16/index.html">6.5.16 Assignment operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../17/index.html">6.5.17 Comma operator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../6/index.html">6.6 Constant expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../7/index.html">6.7 Declarations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../8/index.html">6.8 Statements and blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../9/index.html">6.9 External definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../10/index.html">6.10 Preprocessing directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../11/index.html">6.11 Future language directions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../7/index.html">7. Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../8/index.html">Annex A</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../9/index.html">Annex B</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../10/index.html">Annex C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../11/index.html">Annex D</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../12/index.html">Annex E</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../13/index.html">Annex F</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../14/index.html">Annex G</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../15/index.html">Annex H</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../16/index.html">Annex I</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../17/index.html">Annex J</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../18/index.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">C99 Language Standard</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">6. Language</a></li>
          <li class="breadcrumb-item"><a href="../../index.html">6.5 Expressions</a></li>
          <li class="breadcrumb-item"><a href="../index.html">6.5.2 Postfix operators</a></li>
      <li class="breadcrumb-item active">6.5.2.5 Compound literals</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="../4/index.html" class="btn btn-neutral float-left" title="6.5.2.4 Postfix increment and decrement operators" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../3/index.html" class="btn btn-neutral float-right" title="6.5.3 Unary operators" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="compound-literals">
<span id="id1"></span><h1>6.5.2.5 Compound literals<a class="headerlink" href="#compound-literals" title="Permalink to this heading"></a></h1>
<p class="rubric">Constraints</p>
<div class="snum docutils container" id="p1">
<p><a class="reference internal" href="#p1"><span class="std std-ref">1</span></a></p>
</div>
<p>The type name shall specify an object type or an array of unknown size, but not a variable length array type.</p>
<div class="snum docutils container" id="p2">
<p><a class="reference internal" href="#p2"><span class="std std-ref">2</span></a></p>
</div>
<p>No initializer shall attempt to provide a value for an object not contained within the entire unnamed object specified by the compound literal.</p>
<div class="snum docutils container" id="p3">
<p><a class="reference internal" href="#p3"><span class="std std-ref">3</span></a></p>
</div>
<p>If the compound literal occurs outside the body of a function, the initializer list shall consist of constant expressions.</p>
<p class="rubric">Semantics</p>
<div class="snum docutils container" id="p4">
<p><a class="reference internal" href="#p4"><span class="std std-ref">4</span></a></p>
</div>
<p>A postfix expression that consists of a parenthesized type name followed by a brace- enclosed list of initializers is a compound literal. It provides an unnamed object whose value is given by the initializer list.<a class="footnote-reference brackets" href="#note84" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<div class="snum docutils container" id="p5">
<p><a class="reference internal" href="#p5"><span class="std std-ref">5</span></a></p>
</div>
<p>If the type name specifies an array of unknown size, the size is determined by the initializer list as specified in <a class="reference internal" href="../../../7/8/index.html#id1"><span class="std std-ref">6.7.8</span></a>, and the type of the compound literal is that of the completed array type. Otherwise (when the type name specifies an object type), the type of the compound literal is that specified by the type name. In either case, the result is an lvalue.</p>
<div class="snum docutils container" id="p6">
<p><a class="reference internal" href="#p6"><span class="std std-ref">6</span></a></p>
</div>
<p>The value of the compound literal is that of an unnamed object initialized by the initializer list. If the compound literal occurs outside the body of a function, the object has static storage duration; otherwise, it has automatic storage duration associated with the enclosing block.</p>
<div class="snum docutils container" id="p7">
<p><a class="reference internal" href="#p7"><span class="std std-ref">7</span></a></p>
</div>
<p>All the semantic rules and constraints for initializer lists in <a class="reference internal" href="../../../7/8/index.html#id1"><span class="std std-ref">6.7.8</span></a> are applicable to compound literals.<a class="footnote-reference brackets" href="#note85" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<div class="snum docutils container" id="p8">
<p><a class="reference internal" href="#p8"><span class="std std-ref">8</span></a></p>
</div>
<p>String literals, and compound literals with const-qualified types, need not designate distinct objects.<a class="footnote-reference brackets" href="#note86" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<div class="snum docutils container" id="p9">
<p><a class="reference internal" href="#p9"><span class="std std-ref">9</span></a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EXAMPLE</span> <span class="pre">1</span></code> The file scope definition</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="p">[]){</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">};</span>
</pre></div>
</div>
<p>initializes p to point to the first element of an array of two ints, the first having the value two and the second, four. The expressions in this compound literal are required to be constant. The unnamed object has static storage duration.</p>
<div class="snum docutils container" id="p10">
<p><a class="reference internal" href="#p10"><span class="std std-ref">10</span></a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EXAMPLE</span> <span class="pre">2</span></code> In contrast, in</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="w">      </span><span class="cm">/*...*/</span>
<span class="w">      </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">]){</span><span class="o">*</span><span class="n">p</span><span class="p">};</span>
<span class="w">      </span><span class="cm">/*...*/</span>
<span class="p">}</span>
</pre></div>
</div>
<p>p is assigned the address of the first element of an array of two ints, the first having the value previously pointed to by p and the second, zero. The expressions in this compound literal need not be constant. The unnamed object has automatic storage duration.</p>
<div class="snum docutils container" id="p11">
<p><a class="reference internal" href="#p11"><span class="std std-ref">11</span></a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EXAMPLE</span> <span class="pre">3</span></code> Initializers with designations can be combined with compound literals. Structure objects created using compound literals can be passed to functions without depending on member order:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="n">drawline</span><span class="p">((</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="p">){.</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">},</span>
<span class="w">      </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="p">){.</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">});</span>
</pre></div>
</div>
<p>Or, if drawline instead expected pointers to struct point:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="n">drawline</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="p">){.</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">},</span>
<span class="w">      </span><span class="o">&amp;</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">point</span><span class="p">){.</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">.</span><span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">});</span>
</pre></div>
</div>
<div class="snum docutils container" id="p12">
<p><a class="reference internal" href="#p12"><span class="std std-ref">12</span></a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EXAMPLE</span> <span class="pre">4</span></code> A read-only compound literal can be specified through constructions like:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="p">[]){</span><span class="mf">1e0</span><span class="p">,</span><span class="w"> </span><span class="mf">1e1</span><span class="p">,</span><span class="w"> </span><span class="mf">1e2</span><span class="p">,</span><span class="w"> </span><span class="mf">1e3</span><span class="p">,</span><span class="w"> </span><span class="mf">1e4</span><span class="p">,</span><span class="w"> </span><span class="mf">1e5</span><span class="p">,</span><span class="w"> </span><span class="mf">1e6</span><span class="p">}</span>
</pre></div>
</div>
<div class="snum docutils container" id="p13">
<p><a class="reference internal" href="#p13"><span class="std std-ref">13</span></a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EXAMPLE</span> <span class="pre">5</span></code> The following three expressions have different meanings:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;/tmp/fileXXXXXX&quot;</span>
<span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="p">[]){</span><span class="s">&quot;/tmp/fileXXXXXX&quot;</span><span class="p">}</span>
<span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">[]){</span><span class="s">&quot;/tmp/fileXXXXXX&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>The first always has static storage duration and has type array of char, but need not be modifiable; the last two have automatic storage duration when they occur within the body of a function, and the first of these two is modifiable.</p>
<div class="snum docutils container" id="p14">
<p><a class="reference internal" href="#p14"><span class="std std-ref">14</span></a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EXAMPLE</span> <span class="pre">6</span></code> Like string literals, const-qualified compound literals can be placed into read-only memory and can even be shared. For example,</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="p">[]){</span><span class="s">&quot;abc&quot;</span><span class="p">}</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;abc&quot;</span>
</pre></div>
</div>
<p>might yield 1 if the literals’ storage is shared.</p>
<div class="snum docutils container" id="p15">
<p><a class="reference internal" href="#p15"><span class="std std-ref">15</span></a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EXAMPLE</span> <span class="pre">7</span></code> Since compound literals are unnamed, a single compound literal cannot specify a circularly linked object. For example, there is no way to write a self-referential compound literal that could be used as the function argument in place of the named object endless_zeros below:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">int_list</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">car</span><span class="p">;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">int_list</span><span class="w"> </span><span class="o">*</span><span class="n">cdr</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">int_list</span><span class="w"> </span><span class="n">endless_zeros</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">endless_zeros</span><span class="p">};</span>
<span class="n">eval</span><span class="p">(</span><span class="n">endless_zeros</span><span class="p">);</span>
</pre></div>
</div>
<div class="snum docutils container" id="p16">
<p><a class="reference internal" href="#p16"><span class="std std-ref">16</span></a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EXAMPLE</span> <span class="pre">8</span></code> Each compound literal creates only a single object in a given scope:</p>
<div class="highlight-c99 notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="nl">again</span><span class="p">:</span>
<span class="w">      </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">){</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="w"> </span><span class="p">});</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">goto</span><span class="w"> </span><span class="n">again</span><span class="p">;</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">q</span><span class="o">-&gt;</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function f() always returns the value 1.</p>
<div class="snum docutils container" id="p17">
<p><a class="reference internal" href="#p17"><span class="std std-ref">17</span></a></p>
</div>
<p>Note that if an iteration statement were used instead of an explicit goto and a labeled statement, the lifetime of the unnamed object would be the body of the loop only, and on entry next time around p would have an indeterminate value, which would result in undefined behavior.</p>
<p class="rubric">Forward References</p>
<table class="hlist"><tr><td><ul class="simple">
<li><p><a class="reference internal" href="../../../7/6/index.html#id1"><span class="std std-ref">6.7.6 Type names</span></a></p></li>
</ul>
</td><td><ul class="simple">
<li><p><a class="reference internal" href="../../../7/8/index.html#id1"><span class="std std-ref">6.7.8 Initialization</span></a></p></li>
</ul>
</td></tr></table>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="note84" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>Note that this differs from a cast expression. For example, a cast specifies a conversion to scalar types or void only, and the result of a cast expression is not an lvalue.</p>
</aside>
<aside class="footnote brackets" id="note85" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>For example, subobjects without explicit initializers are initialized to zero.</p>
</aside>
<aside class="footnote brackets" id="note86" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>This allows implementations to share storage for string literals and constant compound literals with the same or overlapping representations.</p>
</aside>
</aside>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../4/index.html" class="btn btn-neutral float-left" title="6.5.2.4 Postfix increment and decrement operators" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../3/index.html" class="btn btn-neutral float-right" title="6.5.3 Unary operators" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>