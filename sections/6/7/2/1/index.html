<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6.7.2.1 Structure and union specifiers &mdash; C99 Language Standard  documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/brand.css" type="text/css" />
    <link rel="shortcut icon" href="../../../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link rel="next" title="6.7.2.2 Enumeration specifiers" href="../2/index.html" />
    <link rel="prev" title="6.7.2 Type specifiers" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            C99 Language Standard
              <img src="../../../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../foreword.html">Foreword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../1/index.html">1. Scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../2/index.html">2. Normative references</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../3/index.html">3. Terms, definitions, and symbols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../4/index.html">4. Conformance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../5/index.html">5. Environment</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">6. Language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../1/index.html">6.1 Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../2/index.html">6.2 Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../3/index.html">6.3 Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../4/index.html">6.4 Lexical elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../5/index.html">6.5 Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../6/index.html">6.6 Constant expressions</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html">6.7 Declarations</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../1/index.html">6.7.1 Storage-class specifiers</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">6.7.2 Type specifiers</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">6.7.2.1 Structure and union specifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../2/index.html">6.7.2.2 Enumeration specifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../3/index.html">6.7.2.3 Tags</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../3/index.html">6.7.3 Type qualifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../4/index.html">6.7.4 Function specifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../5/index.html">6.7.5 Declarators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../6/index.html">6.7.6 Type names</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../7/index.html">6.7.7 Type definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../8/index.html">6.7.8 Initialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../8/index.html">6.8 Statements and blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../9/index.html">6.9 External definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../10/index.html">6.10 Preprocessing directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../11/index.html">6.11 Future language directions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../7/index.html">7. Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../8/index.html">Annex A</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../9/index.html">Annex B</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../10/index.html">Annex C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../11/index.html">Annex D</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../12/index.html">Annex E</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../13/index.html">Annex F</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../14/index.html">Annex G</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../15/index.html">Annex H</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../16/index.html">Annex I</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../17/index.html">Annex J</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../18/index.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">C99 Language Standard</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">6. Language</a></li>
          <li class="breadcrumb-item"><a href="../../index.html">6.7 Declarations</a></li>
          <li class="breadcrumb-item"><a href="../index.html">6.7.2 Type specifiers</a></li>
      <li class="breadcrumb-item active">6.7.2.1 Structure and union specifiers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="../index.html" class="btn btn-neutral float-left" title="6.7.2 Type specifiers" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../2/index.html" class="btn btn-neutral float-right" title="6.7.2.2 Enumeration specifiers" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="structure-and-union-specifiers">
<span id="id1"></span><h1>6.7.2.1 Structure and union specifiers<a class="headerlink" href="#structure-and-union-specifiers" title="Permalink to this heading">ÔÉÅ</a></h1>
<p class="rubric">Syntax</p>
<div class="snum docutils container" id="p1">
<p><a class="reference internal" href="#p1"><span class="std std-ref">1</span></a></p>
</div>
<div class="syntax-block docutils container">
<div class="syntax-production docutils container">
<div class="syntax-definition docutils container">
<p><span class="syn-nonterm">struct-or-union-specifier</span>:</p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">struct-or-union</span> <span class="syn-nonterm">identifier</span><span class="syn-opt">opt</span> <span class="syn-term">{</span> <span class="syn-nonterm">struct-declaration-list</span> <span class="syn-term">}</span></p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">struct-or-union</span> <span class="syn-nonterm">identifier</span></p>
</div>
</div>
<div class="syntax-production docutils container">
<div class="syntax-definition docutils container">
<p><span class="syn-nonterm">struct-or-union</span>:</p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-term">struct</span></p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-term">union</span></p>
</div>
</div>
<div class="syntax-production docutils container">
<div class="syntax-definition docutils container">
<p><span class="syn-nonterm">struct-declaration-list</span>:</p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">struct-declaration</span></p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">struct-declaration-list</span> <span class="syn-nonterm">struct-declaration</span></p>
</div>
</div>
<div class="syntax-production docutils container">
<div class="syntax-definition docutils container">
<p><span class="syn-nonterm">struct-declaration</span>:</p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">specifier-qualifier-list</span> <span class="syn-nonterm">struct-declarator-list</span> <span class="syn-term">;</span></p>
</div>
</div>
<div class="syntax-production docutils container">
<div class="syntax-definition docutils container">
<p><span class="syn-nonterm">specifier-qualifier-list</span>:</p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">type-specifier</span> <span class="syn-nonterm">specifier-qualifier-list</span><span class="syn-opt">opt</span></p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">type-qualifier</span> <span class="syn-nonterm">specifier-qualifier-list</span><span class="syn-opt">opt</span></p>
</div>
</div>
<div class="syntax-production docutils container">
<div class="syntax-definition docutils container">
<p><span class="syn-nonterm">struct-declarator-list</span>:</p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">struct-declarator</span></p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">struct-declarator-list</span> <span class="syn-term">,</span> <span class="syn-nonterm">struct-declarator</span></p>
</div>
</div>
<div class="syntax-production docutils container">
<div class="syntax-definition docutils container">
<p><span class="syn-nonterm">struct-declarator</span>:</p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">declarator</span></p>
</div>
<div class="syntax-rule docutils container">
<p><span class="syn-nonterm">declarator</span><span class="syn-opt">opt</span> <span class="syn-term">:</span> <span class="syn-nonterm">constant-expression</span></p>
</div>
</div>
</div>
<p class="rubric">Constraints</p>
<div class="snum docutils container" id="p2">
<p><a class="reference internal" href="#p2"><span class="std std-ref">2</span></a></p>
</div>
<p>A structure or union shall not contain a member with incomplete or function type (hence, a structure shall not contain an instance of itself, but may contain a pointer to an instance of itself), except that the last member of a structure with more than one named member may have incomplete array type; such a structure (and any union containing, possibly recursively, a member that is such a structure) shall not be a member of a structure or an element of an array.</p>
<div class="snum docutils container" id="p3">
<p><a class="reference internal" href="#p3"><span class="std std-ref">3</span></a></p>
</div>
<p>The expression that specifies the width of a bit-field shall be an integer constant expression with a nonnegative value that does not exceed the width of an object of the type that would be specified were the colon and expression omitted. If the value is zero, the declaration shall have no declarator.</p>
<div class="snum docutils container" id="p4">
<p><a class="reference internal" href="#p4"><span class="std std-ref">4</span></a></p>
</div>
<p>A bit-field shall have a type that is a qualified or unqualified version of _Bool, signed int, unsigned int, or some other implementation-defined type.</p>
<p class="rubric">Semantics</p>
<div class="snum docutils container" id="p5">
<p><a class="reference internal" href="#p5"><span class="std std-ref">5</span></a></p>
</div>
<p>As discussed in <a class="reference internal" href="../../../2/5/index.html#id1"><span class="std std-ref">6.2.5</span></a>, a structure is a type consisting of a sequence of members, whose storage is allocated in an ordered sequence, and a union is a type consisting of a sequence of members whose storage overlap.</p>
<div class="snum docutils container" id="p6">
<p><a class="reference internal" href="#p6"><span class="std std-ref">6</span></a></p>
</div>
<p>Structure and union specifiers have the same form. The keywords struct and union indicate that the type being specified is, respectively, a structure type or a union type.</p>
<div class="snum docutils container" id="p7">
<p><a class="reference internal" href="#p7"><span class="std std-ref">7</span></a></p>
</div>
<p>The presence of a struct-declaration-list in a struct-or-union-specifier declares a new type, within a translation unit. The struct-declaration-list is a sequence of declarations for the members of the structure or union. If the struct-declaration-list contains no named members, the behavior is undefined. The type is incomplete until after the } that terminates the list.</p>
<div class="snum docutils container" id="p8">
<p><a class="reference internal" href="#p8"><span class="std std-ref">8</span></a></p>
</div>
<p>A member of a structure or union may have any object type other than a variably modified type.<a class="footnote-reference brackets" href="#note105" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> In addition, a member may be declared to consist of a specified number of bits (including a sign bit, if any). Such a member is called a bit-field;<a class="footnote-reference brackets" href="#note106" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> its width is preceded by a colon.</p>
<div class="snum docutils container" id="p9">
<p><a class="reference internal" href="#p9"><span class="std std-ref">9</span></a></p>
</div>
<p>A bit-field is interpreted as a signed or unsigned integer type consisting of the specified number of bits.<a class="footnote-reference brackets" href="#note107" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> If the value 0 or 1 is stored into a nonzero-width bit-field of type _Bool, the value of the bit-field shall compare equal to the value stored.</p>
<div class="snum docutils container" id="p10">
<p><a class="reference internal" href="#p10"><span class="std std-ref">10</span></a></p>
</div>
<p>An implementation may allocate any addressable storage unit large enough to hold a bit- field. If enough space remains, a bit-field that immediately follows another bit-field in a structure shall be packed into adjacent bits of the same unit. If insufficient space remains, whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is implementation-defined. The order of allocation of bit-fields within a unit (high-order to low-order or low-order to high-order) is implementation-defined. The alignment of the addressable storage unit is unspecified.</p>
<div class="snum docutils container" id="p11">
<p><a class="reference internal" href="#p11"><span class="std std-ref">11</span></a></p>
</div>
<p>A bit-field declaration with no declarator, but only a colon and a width, indicates an unnamed bit-field.<a class="footnote-reference brackets" href="#note108" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> As a special case, a bit-field structure member with a width of 0 indicates that no further bit-field is to be packed into the unit in which the previous bit- field, if any, was placed.</p>
<div class="snum docutils container" id="p12">
<p><a class="reference internal" href="#p12"><span class="std std-ref">12</span></a></p>
</div>
<p>Each non-bit-field member of a structure or union object is aligned in an implementation- defined manner appropriate to its type.</p>
<div class="snum docutils container" id="p13">
<p><a class="reference internal" href="#p13"><span class="std std-ref">13</span></a></p>
</div>
<p>Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.</p>
<div class="snum docutils container" id="p14">
<p><a class="reference internal" href="#p14"><span class="std std-ref">14</span></a></p>
</div>
<p>The size of a union is sufficient to contain the largest of its members. The value of at most one of the members can be stored in a union object at any time. A pointer to a union object, suitably converted, points to each of its members (or if a member is a bit- field, then to the unit in which it resides), and vice versa.</p>
<div class="snum docutils container" id="p15">
<p><a class="reference internal" href="#p15"><span class="std std-ref">15</span></a></p>
</div>
<p>There may be unnamed padding at the end of a structure or union.</p>
<div class="snum docutils container" id="p16">
<p><a class="reference internal" href="#p16"><span class="std std-ref">16</span></a></p>
</div>
<p>As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. In most situations, the flexible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply. However, when a . (or -&gt;) operator has a left operand that is (a pointer to) a structure with a flexible array member and the right operand names that member, it behaves as if that member were replaced with the longest array (with the same element type) that would not make the structure larger than the object being accessed; the offset of the array shall remain that of the flexible array member, even if this would differ from that of the replacement array. If this array would have no elements, it behaves as if it had one element but the behavior is undefined if any attempt is made to access that element or to generate a pointer one past it.</p>
<div class="snum docutils container" id="p17">
<p><a class="reference internal" href="#p17"><span class="std std-ref">17</span></a></p>
</div>
<p>EXAMPLE After the declaration:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">[];</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>the structure struct s has a flexible array member d. A typical way to use this is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* some value */</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]));</span>
</pre></div>
</div>
<p>and assuming that the call to malloc succeeds, the object pointed to by p behaves, for most purposes, as if p had been declared as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">m</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
</pre></div>
</div>
<p>(there are circumstances in which this equivalence is broken; in particular, the offsets of member d might not be the same).</p>
<div class="snum docutils container" id="p18">
<p><a class="reference internal" href="#p18"><span class="std std-ref">18</span></a></p>
</div>
<p>Following the above declaration:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w">                        </span><span class="c1">//   valid</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">4.2</span><span class="w"> </span><span class="p">}};</span><span class="w">                </span><span class="c1">//   invalid</span>
<span class="n">t1</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">                                   </span><span class="c1">//   valid</span>
<span class="n">t1</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.2</span><span class="p">;</span><span class="w">                              </span><span class="c1">//   might be undefined behavior</span>
</pre></div>
</div>
<p>The initialization of t2 is invalid (and violates a constraint) because struct s is treated as if it did not contain member d. The assignment to t1.d[0] is probably undefined behavior, but it is possible that</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span>
</pre></div>
</div>
<p>in which case the assignment would be legitimate. Nevertheless, it cannot appear in strictly conforming code.</p>
<div class="snum docutils container" id="p19">
<p><a class="reference internal" href="#p19"><span class="std std-ref">19</span></a></p>
</div>
<p>After the further declaration:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ss</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>the expressions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ss</span><span class="p">)</span>
<span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>are always equal to 1.</p>
<div class="snum docutils container" id="p20">
<p><a class="reference internal" href="#p20"><span class="std std-ref">20</span></a></p>
</div>
<p>If sizeof (double) is 8, then after the following code is executed:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="o">*</span><span class="n">s1</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="w"> </span><span class="o">*</span><span class="n">s2</span><span class="p">;</span>
<span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span>
<span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">46</span><span class="p">);</span>
</pre></div>
</div>
<p>and assuming that the calls to malloc succeed, the objects pointed to by s1 and s2 behave, for most purposes, as if the identifiers had been declared as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">s1</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">s2</span><span class="p">;</span>
</pre></div>
</div>
<div class="snum docutils container" id="p21">
<p><a class="reference internal" href="#p21"><span class="std std-ref">21</span></a></p>
</div>
<p>Following the further successful assignments:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
</pre></div>
</div>
<p>they then behave as if the declarations were:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">s2</span><span class="p">;</span>
</pre></div>
</div>
<p>and:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">dp</span><span class="p">;</span>
<span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">s1</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w">           </span><span class="c1">//   valid</span>
<span class="o">*</span><span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">                   </span><span class="c1">//   valid</span>
<span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">s2</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w">           </span><span class="c1">//   valid</span>
<span class="o">*</span><span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">                   </span><span class="c1">//   undefined behavior</span>
</pre></div>
</div>
<div class="snum docutils container" id="p22">
<p><a class="reference internal" href="#p22"><span class="std std-ref">22</span></a></p>
</div>
<p>The assignment:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">s2</span><span class="p">;</span>
</pre></div>
</div>
<p>only copies the member n; if any of the array elements are within the first sizeof (struct s) bytes of the structure, they might be copied or simply overwritten with indeterminate values.</p>
<p class="rubric">Forward References</p>
<table class="hlist"><tr><td><ul class="simple">
<li><p><a class="reference internal" href="../3/index.html#id1"><span class="std std-ref">6.7.2.3 Tags</span></a></p></li>
</ul>
</td><td><ul class="simple">
</ul>
</td></tr></table>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="note105" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>A structure or union can not contain a member with a variably modified type because member names are not ordinary identifiers as defined in <a class="reference internal" href="../../../2/3/index.html#id1"><span class="std std-ref">6.2.3</span></a>.</p>
</aside>
<aside class="footnote brackets" id="note106" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>The unary &amp; (address-of) operator cannot be applied to a bit-field object; thus, there are no pointers to or arrays of bit-field objects.</p>
</aside>
<aside class="footnote brackets" id="note107" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>As specified in <a class="reference internal" href="../index.html#id1"><span class="std std-ref">6.7.2</span></a> above, if the actual type specifier used is int or a typedef-name defined as int, then it is implementation-defined whether the bit-field is signed or unsigned.</p>
</aside>
<aside class="footnote brackets" id="note108" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p>An unnamed bit-field structure member is useful for padding to conform to externally imposed layouts.</p>
</aside>
</aside>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="6.7.2 Type specifiers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../2/index.html" class="btn btn-neutral float-right" title="6.7.2.2 Enumeration specifiers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>